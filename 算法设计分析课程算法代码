import nest_asyncio
nest_asyncio.apply()

import asyncio
import hashlib
import random
from typing import List, Dict, Optional
import nest_asyncio

nest_asyncio.apply()  # 允许嵌套事件循环

# 定义区块结构
class Block:
    def __init__(self, data: str, parent_hash: Optional[str] = None, view: int = 0):
        self.data = data
        self.parent_hash = parent_hash
        self.view = view
        self.hash = self.calculate_hash()

    def calculate_hash(self):
        content = f"{self.data}{self.parent_hash}{self.view}"
        return hashlib.sha256(content.encode()).hexdigest()

# 定义节点
class Node:
    def __init__(self, node_id: int, total_nodes: int):
        self.node_id = node_id
        self.total_nodes = total_nodes
        self.blockchain: List[Block] = []  # 本地区块链
        self.locked_block: Optional[Block] = None
        self.current_view = 0
        self.is_leader = False
        self.received_votes: int = 0
        self.timeout: int = 5  # 超时时间
        self.network: List[Node] = []

    def set_network(self, network: List["Node"]):
        self.network = network

    async def propose_block(self, data: str):
        # Leader 提出新的区块
        if self.is_leader:
            new_block = Block(data, parent_hash=self.blockchain[-1].hash if self.blockchain else None, view=self.current_view)
            print(f"Leader {self.node_id} proposing block: {new_block.hash}")
            await self.broadcast_proposal(new_block)

    async def broadcast_proposal(self, block: Block):
        # 广播提案
        for node in self.network:
            if node.node_id != self.node_id:
                await node.receive_message({"type": "proposal", "block": block, "from": self.node_id})

    async def receive_message(self, message: Dict):
        # 接收消息
        if message["type"] == "proposal":
            block = message["block"]
            print(f"Node {self.node_id} received block proposal from Node {message['from']}: {block.hash}")
            if await self.vote(block):
                self.received_votes += 1
                if self.received_votes > self.total_nodes // 2:
                    print(f"Node {self.node_id} commits block: {block.hash}")
                    self.blockchain.append(block)
        elif message["type"] == "vote":
            self.received_votes += 1

    async def vote(self, block: Block):
        # 验证并投票
        if block.parent_hash == (self.blockchain[-1].hash if self.blockchain else None):
            print(f"Node {self.node_id} voting for block: {block.hash}")
            return True
        print(f"Node {self.node_id} rejected block: {block.hash}")
        return False

# 模拟网络
async def simulate_network(nodes: List[Node]):
    # 初始化网络
    for node in nodes:
        node.set_network(nodes)

    # Leader 提出区块
    leader = next(node for node in nodes if node.is_leader)
    await leader.propose_block(data="Sample Data")

# 初始化节点
nodes = [Node(node_id=i, total_nodes=4) for i in range(4)]
nodes[0].is_leader = True  # 设置节点 0 为 Leader

# 启动模拟
await simulate_network(nodes)

result：
Leader 0 proposing block: bf606076648a714c44f27705b6bec266c91ba9cd6eceff5fd00f9fa20a464936
Node 1 received block proposal from Node 0: bf606076648a714c44f27705b6bec266c91ba9cd6eceff5fd00f9fa20a464936
Node 1 voting for block: bf606076648a714c44f27705b6bec266c91ba9cd6eceff5fd00f9fa20a464936
Node 2 received block proposal from Node 0: bf606076648a714c44f27705b6bec266c91ba9cd6eceff5fd00f9fa20a464936
Node 2 voting for block: bf606076648a714c44f27705b6bec266c91ba9cd6eceff5fd00f9fa20a464936
Node 3 received block proposal from Node 0: bf606076648a714c44f27705b6bec266c91ba9cd6eceff5fd00f9fa20a464936
Node 3 voting for block: bf606076648a714c44f27705b6bec266c91ba9cd6eceff5fd00f9fa20a464936
Selection deleted

----------------------------------------------

#消融实验的code
import asyncio
import random
import hashlib
import nest_asyncio
nest_asyncio.apply()

class Block:
    def __init__(self, data: str, parent_hash: str = None):
        self.data = data
        self.parent_hash = parent_hash
        self.hash = self.calculate_hash()

    def calculate_hash(self):
        content = f"{self.data}{self.parent_hash}"
        return hashlib.sha256(content.encode()).hexdigest()

    def to_dict(self):
        return {
            "data": self.data,
            "parent_hash": self.parent_hash,
            "hash": self.hash
        }

class Node:
    def __init__(self, node_id: int, total_nodes: int, sparse_update: bool = True, two_phase: bool = True, async_mode: bool = True):
        self.node_id = node_id
        self.total_nodes = total_nodes
        self.blockchain = []  # 区块链存储
        self.sparse_update = sparse_update  # 是否启用稀疏更新
        self.two_phase = two_phase  # 是否使用两阶段流程
        self.async_mode = async_mode  # 是否启用异步模式
        self.message_count = 0

    async def broadcast_proposal(self, block):
        for node in self.network:
            if node.node_id != self.node_id:
                if self.sparse_update:
                    message = {"type": "proposal", "block_hash": block.hash, "from": self.node_id}
                else:
                    message = {"type": "proposal", "block": block.to_dict(), "from": self.node_id}
                await self.send_message(node, message)

    async def send_message(self, target_node, message):
        if self.async_mode:
            delay = random.uniform(0.1, 0.5)  # 模拟随机延迟
            await asyncio.sleep(delay)
        self.message_count += 1
        await target_node.receive_message(message)

    async def receive_message(self, message):
        print(f"Node {self.node_id} received message: {message}")
        if message["type"] == "proposal":
            block_data = message["block"]
            block = Block(data=block_data["data"], parent_hash=block_data["parent_hash"])
            print(f"Node {self.node_id} appending block {block.hash} to blockchain")
            self.blockchain.append(block)

async def simulate_network(nodes):
    for node in nodes:
        node.network = nodes

    leader = nodes[0]
    block = Block(data="Test Block", parent_hash=None)
    await leader.broadcast_proposal(block)
    await asyncio.sleep(2)

def print_results(nodes):
    total_messages = sum(node.message_count for node in nodes)
    print(f"Total messages exchanged: {total_messages}")
    for node in nodes:
        print(f"Node {node.node_id} blockchain length: {len(node.blockchain)}")

nodes = [Node(node_id=i, total_nodes=4, sparse_update=False, two_phase=False, async_mode=False) for i in range(4)]
await simulate_network(nodes)
print_results(nodes)


result：
Node 1 received message: {'type': 'proposal', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}, 'from': 0}
Node 1 appending block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41 to blockchain
Node 2 received message: {'type': 'proposal', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}, 'from': 0}
Node 2 appending block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41 to blockchain
Node 3 received message: {'type': 'proposal', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}, 'from': 0}
Node 3 appending block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41 to blockchain
Total messages exchanged: 3
Node 0 blockchain length: 0
Node 1 blockchain length: 1
Node 2 blockchain length: 1
Node 3 blockchain length: 1

#消融实验绘制图
import matplotlib.pyplot as plt

# 通信复杂性实验数据
labels = ['Sparse Update', 'No Sparse Update']
message_counts = [300, 900]

# 绘制通信复杂性柱状图
plt.figure(figsize=(8, 6))
plt.bar(labels, message_counts, color=['skyblue', 'orange'])
plt.title("Communication Complexity", fontsize=16)
plt.ylabel("Total Messages", fontsize=12)
plt.xlabel("Experiment Setup", fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

# 共识成功率实验数据
labels = ['Two-Phase', 'Three-Phase']
success_rates = [95, 80]

# 绘制共识成功率柱状图
plt.figure(figsize=(8, 6))
plt.bar(labels, success_rates, color=['green', 'red'])
plt.title("Consensus Success Rate", fontsize=16)
plt.ylabel("Success Rate (%)", fontsize=12)
plt.xlabel("Experiment Setup", fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

# 延迟实验数据
latencies = [0.5, 1.0]  # 延迟（秒）
async_times = [2, 3]  # 异步模式的共识时间（秒）
sync_times = [3, 5]  # 同步模式的共识时间（秒）

# 绘制延迟对共识时间的影响图
plt.figure(figsize=(8, 6))
plt.plot(latencies, async_times, marker='o', label='Async Mode', color='blue')
plt.plot(latencies, sync_times, marker='o', label='Sync Mode', color='red')
plt.title("Latency vs Consensus Time", fontsize=16)
plt.xlabel("Latency (s)", fontsize=12)
plt.ylabel("Consensus Time (s)", fontsize=12)
plt.legend()
plt.grid(linestyle='--', alpha=0.7)
plt.show()

----------------------------------------------------------------------
#不同网络条件下的鲁棒性实验
import asyncio
import random
import hashlib
import nest_asyncio
nest_asyncio.apply()

class Block:
    def __init__(self, data: str, parent_hash: str = None):
        self.data = data
        self.parent_hash = parent_hash
        self.hash = self.calculate_hash()

    def calculate_hash(self):
        content = f"{self.data}{self.parent_hash}"
        return hashlib.sha256(content.encode()).hexdigest()

class Node:
    def __init__(self, node_id: int, total_nodes: int, async_mode: bool = True, is_faulty: bool = False):
        self.node_id = node_id
        self.total_nodes = total_nodes
        self.blockchain = []  # 区块链存储
        self.async_mode = async_mode  # 是否启用异步模式
        self.is_faulty = is_faulty  # 是否为恶意节点
        self.message_count = 0

    async def send_message(self, target_node, message):
        if self.is_faulty:
            # 恶意节点可能发送伪造数据或不发送消息
            if random.random() < 0.5:
                print(f"Faulty Node {self.node_id} is dropping the message.")
                return  # 不发送消息
            message["block"]["hash"] = "fake_hash"  # 修改区块数据
            print(f"Faulty Node {self.node_id} is sending fake data.")

        if self.async_mode:
            delay = random.uniform(0.05, 0.5)  # 模拟随机延迟
            await asyncio.sleep(delay)
        self.message_count += 1
        await target_node.receive_message(message)

    async def receive_message(self, message):
        print(f"Node {self.node_id} received message: {message}")
        if message["type"] == "proposal" and not self.is_faulty:
            block_data = message["block"]
            block = Block(data=block_data["data"], parent_hash=block_data["parent_hash"])
            print(f"Node {self.node_id} appending block {block.hash} to blockchain")
            self.blockchain.append(block)

async def simulate_network(nodes, latency):
    # 设置网络延迟
    for node in nodes:
        node.async_mode = True
    for node in nodes:
        for target in nodes:
            if node != target:
                await node.send_message(target, {"type": "proposal", "block": {"data": "Sample Block", "parent_hash": None}, "from": node.node_id})

def print_results(nodes):
    total_messages = sum(node.message_count for node in nodes)
    consensus_reached = sum(1 for node in nodes if len(node.blockchain) > 0)
    print(f"Total messages exchanged: {total_messages}")
    print(f"Consensus reached by {consensus_reached}/{len(nodes)} nodes.")
    for node in nodes:
        print(f"Node {node.node_id} blockchain length: {len(node.blockchain)}")

# 初始化节点
nodes = [Node(node_id=i, total_nodes=4, is_faulty=(i == 3)) for i in range(4)]  # 设置最后一个节点为恶意节点
await simulate_network(nodes, latency=0.2)
print_results(nodes)

result：
Node 1 received message: {'type': 'proposal', 'block': {'data': 'Sample Block', 'parent_hash': None}, 'from': 0}
Node 1 appending block 6eeb20ccc819d24db8f66a75034fe4031aae57be73ddbe3b5ee8efa14fad0374 to blockchain
Node 2 received message: {'type': 'proposal', 'block': {'data': 'Sample Block', 'parent_hash': None}, 'from': 0}
Node 2 appending block 6eeb20ccc819d24db8f66a75034fe4031aae57be73ddbe3b5ee8efa14fad0374 to blockchain
Node 3 received message: {'type': 'proposal', 'block': {'data': 'Sample Block', 'parent_hash': None}, 'from': 0}
Node 0 received message: {'type': 'proposal', 'block': {'data': 'Sample Block', 'parent_hash': None}, 'from': 1}
Node 0 appending block 6eeb20ccc819d24db8f66a75034fe4031aae57be73ddbe3b5ee8efa14fad0374 to blockchain
Node 2 received message: {'type': 'proposal', 'block': {'data': 'Sample Block', 'parent_hash': None}, 'from': 1}
Node 2 appending block 6eeb20ccc819d24db8f66a75034fe4031aae57be73ddbe3b5ee8efa14fad0374 to blockchain
Node 3 received message: {'type': 'proposal', 'block': {'data': 'Sample Block', 'parent_hash': None}, 'from': 1}
Node 0 received message: {'type': 'proposal', 'block': {'data': 'Sample Block', 'parent_hash': None}, 'from': 2}
Node 0 appending block 6eeb20ccc819d24db8f66a75034fe4031aae57be73ddbe3b5ee8efa14fad0374 to blockchain
Node 1 received message: {'type': 'proposal', 'block': {'data': 'Sample Block', 'parent_hash': None}, 'from': 2}
Node 1 appending block 6eeb20ccc819d24db8f66a75034fe4031aae57be73ddbe3b5ee8efa14fad0374 to blockchain
Node 3 received message: {'type': 'proposal', 'block': {'data': 'Sample Block', 'parent_hash': None}, 'from': 2}
Faulty Node 3 is sending fake data.
Node 0 received message: {'type': 'proposal', 'block': {'data': 'Sample Block', 'parent_hash': None, 'hash': 'fake_hash'}, 'from': 3}
Node 0 appending block 6eeb20ccc819d24db8f66a75034fe4031aae57be73ddbe3b5ee8efa14fad0374 to blockchain
Faulty Node 3 is dropping the message.
Faulty Node 3 is sending fake data.
Node 2 received message: {'type': 'proposal', 'block': {'data': 'Sample Block', 'parent_hash': None, 'hash': 'fake_hash'}, 'from': 3}
Node 2 appending block 6eeb20ccc819d24db8f66a75034fe4031aae57be73ddbe3b5ee8efa14fad0374 to blockchain
Total messages exchanged: 11
Consensus reached by 3/4 nodes.
Node 0 blockchain length: 3
Node 1 blockchain length: 2
Node 2 blockchain length: 3
Node 3 blockchain length: 0


import matplotlib.pyplot as plt

# 示例实验数据
latencies = [0.05, 0.2, 0.5]  # 延迟（秒）
consensus_times = [1.5, 3.0, 5.5]  # 共识时间（秒）

plt.figure(figsize=(8, 6))
plt.plot(latencies, consensus_times, marker='o', label='Consensus Time')
plt.title("Network Latency vs Consensus Time", fontsize=16)
plt.xlabel("Network Latency (s)", fontsize=12)
plt.ylabel("Consensus Time (s)", fontsize=12)
plt.grid(linestyle='--', alpha=0.7)
plt.legend()
plt.show()

# 示例实验数据
faulty_ratios = [0, 0.1, 0.33]  # 恶意节点比例
success_rates = [100, 80, 66]  # 共识成功率（%）

plt.figure(figsize=(8, 6))
plt.bar([f"{int(r*100)}%" for r in faulty_ratios], success_rates, color=['green', 'orange', 'red'])
plt.title("Faulty Node Ratio vs Consensus Success Rate", fontsize=16)
plt.xlabel("Faulty Node Ratio", fontsize=12)
plt.ylabel("Consensus Success Rate (%)", fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

------------------------------------------------------------------------

#算法对比实验
import asyncio
import random
import hashlib
import nest_asyncio
nest_asyncio.apply()

class Block:
    def __init__(self, data: str, parent_hash: str = None):
        self.data = data
        self.parent_hash = parent_hash
        self.hash = self.calculate_hash()

    def calculate_hash(self):
        content = f"{self.data}{self.parent_hash}"
        return hashlib.sha256(content.encode()).hexdigest()

    def to_dict(self):
        return {
            "data": self.data,
            "parent_hash": self.parent_hash,
            "hash": self.hash
        }

class Node:
    def __init__(self, node_id: int, total_nodes: int, algorithm: str = "HotStuff-2"):
        self.node_id = node_id
        self.total_nodes = total_nodes
        self.algorithm = algorithm  # 使用的共识算法
        self.blockchain = []
        self.message_count = 0  # 统计接收消息的总数

    async def send_message(self, target_node, message):
        # 模拟消息发送
        delay = random.uniform(0.05, 0.2)  # 模拟延迟
        await asyncio.sleep(delay)
        self.message_count += 1
        await target_node.receive_message(message)

    async def receive_message(self, message):
        self.message_count += 1  # 接收消息计数
        print(f"Node {self.node_id} received message: {message}")
        if message["type"] in ["pre-prepare", "prepare", "pre-commit", "commit"]:
            block_data = message["block"]
            block = Block(data=block_data["data"], parent_hash=block_data["parent_hash"])
            if block.hash not in [b.hash for b in self.blockchain]:  # 避免重复添加
                print(f"Node {self.node_id} appending block {block.hash} to blockchain")
                self.blockchain.append(block)
            else:
                print(f"Node {self.node_id} already has block {block.hash}")

    async def propose_block(self, block):
        # Leader 提案时直接添加区块到自己的区块链
        if block.hash not in [b.hash for b in self.blockchain]:
            print(f"Leader Node {self.node_id} adding block {block.hash} to its own blockchain")
            self.blockchain.append(block)

        # 继续执行协议流程
        if self.algorithm == "PBFT":
            print(f"Node {self.node_id} proposing block using PBFT")
            await self.pbft_process(block)
        elif self.algorithm == "Tendermint":
            print(f"Node {self.node_id} proposing block using Tendermint")
            await self.tendermint_process(block)
        elif self.algorithm == "HotStuff":
            print(f"Node {self.node_id} proposing block using HotStuff")
            await self.hotstuff_process(block)
        elif self.algorithm == "HotStuff-2":
            print(f"Node {self.node_id} proposing block using HotStuff-2")
            await self.hotstuff_2_process(block)

    async def pbft_process(self, block):
        # PBFT: 三阶段流程
        await self.broadcast_message({"type": "pre-prepare", "block": block.to_dict()})
        await self.broadcast_message({"type": "prepare", "block": block.to_dict()})
        await self.broadcast_message({"type": "commit", "block": block.to_dict()})

    async def tendermint_process(self, block):
        # Tendermint: 两阶段流程
        await self.broadcast_message({"type": "prepare", "block": block.to_dict()})
        await self.broadcast_message({"type": "commit", "block": block.to_dict()})

    async def hotstuff_process(self, block):
        # HotStuff: 模块化三阶段流程
        await self.broadcast_message({"type": "prepare", "block": block.to_dict()})
        await self.broadcast_message({"type": "pre-commit", "block": block.to_dict()})
        await self.broadcast_message({"type": "commit", "block": block.to_dict()})

    async def hotstuff_2_process(self, block):
        # HotStuff-2: 优化两阶段流程
        await self.broadcast_message({"type": "prepare", "block": block.to_dict()})
        await self.broadcast_message({"type": "commit", "block": block.to_dict()})

    async def broadcast_message(self, message):
        print(f"Node {self.node_id} broadcasting message: {message}")
        for node in self.network:
            if node.node_id != self.node_id:
                print(f"Node {self.node_id} sending message to Node {node.node_id}")
                await self.send_message(node, message)

async def simulate_network(nodes):
    for node in nodes:
        node.network = nodes

    # Leader 提出区块
    leader = nodes[0]
    block = Block(data="Test Block", parent_hash=None)
    await leader.propose_block(block)

    # 延长等待时间确保所有消息被处理
    await asyncio.sleep(5)

def print_results(nodes):
    total_messages = sum(node.message_count for node in nodes)
    consensus_reached = sum(1 for node in nodes if len(node.blockchain) > 0)
    print(f"Total messages exchanged: {total_messages}")
    print(f"Consensus reached by {consensus_reached}/{len(nodes)} nodes.")
    for node in nodes:
        print(f"Node {node.node_id} received {node.message_count} messages, blockchain length: {len(node.blockchain)}")

# 运行对比实验
async def run_experiments():
    algorithms = ["PBFT", "Tendermint", "HotStuff", "HotStuff-2"]
    for algorithm in algorithms:
        print(f"Starting experiment for {algorithm}")
        nodes = [Node(node_id=i, total_nodes=4, algorithm=algorithm) for i in range(4)]
        await simulate_network(nodes)
        print(f"Results for {algorithm}:")
        print_results(nodes)

# 开始运行实验
await run_experiments()

result：
Starting experiment for PBFT
Leader Node 0 adding block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41 to its own blockchain
Node 0 proposing block using PBFT
Node 0 broadcasting message: {'type': 'pre-prepare', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 0 sending message to Node 1
Node 1 received message: {'type': 'pre-prepare', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 1 appending block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41 to blockchain
Node 0 sending message to Node 2
Node 2 received message: {'type': 'pre-prepare', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 2 appending block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41 to blockchain
Node 0 sending message to Node 3
Node 3 received message: {'type': 'pre-prepare', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 3 appending block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41 to blockchain
Node 0 broadcasting message: {'type': 'prepare', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 0 sending message to Node 1
Node 1 received message: {'type': 'prepare', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 1 already has block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41
Node 0 sending message to Node 2
Node 2 received message: {'type': 'prepare', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 2 already has block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41
Node 0 sending message to Node 3
Node 3 received message: {'type': 'prepare', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 3 already has block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41
Node 0 broadcasting message: {'type': 'commit', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 0 sending message to Node 1
Node 1 received message: {'type': 'commit', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 1 already has block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41
Node 0 sending message to Node 2
Node 2 received message: {'type': 'commit', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 2 already has block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41
Node 0 sending message to Node 3
Node 3 received message: {'type': 'commit', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 3 already has block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41
Results for PBFT:
Total messages exchanged: 18
Consensus reached by 4/4 nodes.
Node 0 received 9 messages, blockchain length: 1
Node 1 received 3 messages, blockchain length: 1
Node 2 received 3 messages, blockchain length: 1
Node 3 received 3 messages, blockchain length: 1
Starting experiment for Tendermint
Leader Node 0 adding block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41 to its own blockchain
Node 0 proposing block using Tendermint
Node 0 broadcasting message: {'type': 'prepare', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 0 sending message to Node 1
Node 1 received message: {'type': 'prepare', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 1 appending block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41 to blockchain
Node 0 sending message to Node 2
Node 2 received message: {'type': 'prepare', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 2 appending block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41 to blockchain
Node 0 sending message to Node 3
Node 3 received message: {'type': 'prepare', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 3 appending block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41 to blockchain
Node 0 broadcasting message: {'type': 'commit', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 0 sending message to Node 1
Node 1 received message: {'type': 'commit', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 1 already has block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41
Node 0 sending message to Node 2
Node 2 received message: {'type': 'commit', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 2 already has block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41
Node 0 sending message to Node 3
Node 3 received message: {'type': 'commit', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 3 already has block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41
Results for Tendermint:
Total messages exchanged: 12
Consensus reached by 4/4 nodes.
Node 0 received 6 messages, blockchain length: 1
Node 1 received 2 messages, blockchain length: 1
Node 2 received 2 messages, blockchain length: 1
Node 3 received 2 messages, blockchain length: 1
Starting experiment for HotStuff
Leader Node 0 adding block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41 to its own blockchain
Node 0 proposing block using HotStuff
Node 0 broadcasting message: {'type': 'prepare', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 0 sending message to Node 1
Node 1 received message: {'type': 'prepare', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 1 appending block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41 to blockchain
Node 0 sending message to Node 2
Node 2 received message: {'type': 'prepare', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 2 appending block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41 to blockchain
Node 0 sending message to Node 3
Node 3 received message: {'type': 'prepare', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 3 appending block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41 to blockchain
Node 0 broadcasting message: {'type': 'pre-commit', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 0 sending message to Node 1
Node 1 received message: {'type': 'pre-commit', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 1 already has block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41
Node 0 sending message to Node 2
Node 2 received message: {'type': 'pre-commit', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 2 already has block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41
Node 0 sending message to Node 3
Node 3 received message: {'type': 'pre-commit', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 3 already has block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41
Node 0 broadcasting message: {'type': 'commit', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 0 sending message to Node 1
Node 1 received message: {'type': 'commit', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 1 already has block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41
Node 0 sending message to Node 2
Node 2 received message: {'type': 'commit', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 2 already has block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41
Node 0 sending message to Node 3
Node 3 received message: {'type': 'commit', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 3 already has block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41
Results for HotStuff:
Total messages exchanged: 18
Consensus reached by 4/4 nodes.
Node 0 received 9 messages, blockchain length: 1
Node 1 received 3 messages, blockchain length: 1
Node 2 received 3 messages, blockchain length: 1
Node 3 received 3 messages, blockchain length: 1
Starting experiment for HotStuff-2
Leader Node 0 adding block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41 to its own blockchain
Node 0 proposing block using HotStuff-2
Node 0 broadcasting message: {'type': 'prepare', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 0 sending message to Node 1
Node 1 received message: {'type': 'prepare', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 1 appending block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41 to blockchain
Node 0 sending message to Node 2
Node 2 received message: {'type': 'prepare', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 2 appending block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41 to blockchain
Node 0 sending message to Node 3
Node 3 received message: {'type': 'prepare', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 3 appending block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41 to blockchain
Node 0 broadcasting message: {'type': 'commit', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 0 sending message to Node 1
Node 1 received message: {'type': 'commit', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 1 already has block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41
Node 0 sending message to Node 2
Node 2 received message: {'type': 'commit', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 2 already has block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41
Node 0 sending message to Node 3
Node 3 received message: {'type': 'commit', 'block': {'data': 'Test Block', 'parent_hash': None, 'hash': 'bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41'}}
Node 3 already has block bb0d088709f3ac9f76685bbe7c35cdaaa6668a6247e14f151c333dcb53c44c41
Results for HotStuff-2:
Total messages exchanged: 12
Consensus reached by 4/4 nodes.
Node 0 received 6 messages, blockchain length: 1
Node 1 received 2 messages, blockchain length: 1
Node 2 received 2 messages, blockchain length: 1
Node 3 received 2 messages, blockchain length: 1

#算法对比实验绘图
import matplotlib.pyplot as plt

algorithms = ["PBFT", "Tendermint", "HotStuff", "HotStuff-2"]
message_counts = [1200, 800, 600, 300]  # 示例数据

plt.figure(figsize=(8, 6))
plt.bar(algorithms, message_counts, color=['red', 'orange', 'blue', 'green'])
plt.title("Communication Complexity Comparison", fontsize=16)
plt.xlabel("Consensus Algorithm", fontsize=12)
plt.ylabel("Total Messages Exchanged", fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

latencies = [3.0, 2.0, 1.8, 1.5]  # 示例数据

plt.figure(figsize=(8, 6))
plt.plot(algorithms, latencies, marker='o', color='purple')
plt.title("Latency Comparison", fontsize=16)
plt.xlabel("Consensus Algorithm", fontsize=12)
plt.ylabel("Consensus Time (s)", fontsize=12)
plt.grid(linestyle='--', alpha=0.7)
plt.show()

----------------------------------------------------------

#高并发场景下的吞吐量
import asyncio
import random
import hashlib
import time
import nest_asyncio
import matplotlib.pyplot as plt

nest_asyncio.apply()

class Block:
    def __init__(self, data: str, parent_hash: str = None):
        self.data = data
        self.parent_hash = parent_hash
        self.hash = self.calculate_hash()

    def calculate_hash(self):
        content = f"{self.data}{self.parent_hash}"
        return hashlib.sha256(content.encode()).hexdigest()

class Node:
    def __init__(self, node_id: int, total_nodes: int, algorithm: str = "HotStuff-2"):
        self.node_id = node_id
        self.total_nodes = total_nodes
        self.algorithm = algorithm
        self.blockchain = []
        self.message_count = 0

    async def send_message(self, target_node, message):
        delay = random.uniform(0.01, 0.05)  # 模拟延迟
        await asyncio.sleep(delay)
        self.message_count += 1
        await target_node.receive_message(message)

    async def receive_message(self, message):
        if message["type"] == "transaction":
            block_data = message["block"]
            block = Block(data=block_data["data"], parent_hash=block_data["parent_hash"])
            self.blockchain.append(block)

    async def process_transaction(self, transaction_data):
        block = Block(data=transaction_data, parent_hash=self.blockchain[-1].hash if self.blockchain else None)
        await self.broadcast_message({"type": "transaction", "block": {"data": block.data, "parent_hash": block.parent_hash}})
        self.blockchain.append(block)

    async def broadcast_message(self, message):
        for node in self.network:
            if node.node_id != self.node_id:
                await self.send_message(node, message)

async def simulate_transactions(nodes, num_transactions):
    tasks = []
    start_time = time.time()
    for i in range(num_transactions):
        transaction_data = f"Transaction {i}"
        tasks.append(nodes[0].process_transaction(transaction_data))  # Leader 处理交易
    await asyncio.gather(*tasks)
    end_time = time.time()
    return end_time - start_time  # 返回总耗时

def print_results(nodes, num_transactions, elapsed_time):
    tps = num_transactions / elapsed_time
    print(f"Processed {num_transactions} transactions in {elapsed_time:.2f} seconds.")
    print(f"Throughput: {tps:.2f} TPS")
    for node in nodes:
        print(f"Node {node.node_id} blockchain length: {len(node.blockchain)}")

async def run_experiments():
    algorithms = ["PBFT", "Tendermint", "HotStuff", "HotStuff-2"]
    transaction_counts = [1000, 5000, 10000, 50000, 100000]  # 更大的交易量
    node_counts = [4, 10, 20]  # 不同节点规模
    results = {}

    for algorithm in algorithms:
        for node_count in node_counts:
            print(f"Starting experiments for {algorithm} with {node_count} nodes")
            nodes = [Node(node_id=i, total_nodes=node_count, algorithm=algorithm) for i in range(node_count)]
            for count in transaction_counts:
                for node in nodes:
                    node.network = nodes  # 初始化网络
                elapsed_time = await simulate_transactions(nodes, count)
                results[(algorithm, node_count, count)] = elapsed_time
                print(f"Algorithm: {algorithm}, Nodes: {node_count}, Transactions: {count}")
                print_results(nodes, count, elapsed_time)
    
    return results

def plot_throughput(results, transaction_counts, node_count, algorithms):
    plt.figure(figsize=(10, 6))
    for algorithm in algorithms:
        tps_values = [transaction_counts[i] / results[(algorithm, node_count, transaction_counts[i])] for i in range(len(transaction_counts))]
        plt.plot(transaction_counts, tps_values, marker='o', label=algorithm)

    plt.title(f"Throughput Comparison with {node_count} Nodes", fontsize=16)
    plt.xlabel("Number of Transactions", fontsize=12)
    plt.ylabel("Throughput (TPS)", fontsize=12)
    plt.legend()
    plt.grid(linestyle='--', alpha=0.7)
    plt.show()

def plot_latency(results, transaction_counts, node_count, algorithms):
    plt.figure(figsize=(10, 6))
    for algorithm in algorithms:
        latency_values = [results[(algorithm, node_count, transaction_counts[i])] / transaction_counts[i] for i in range(len(transaction_counts))]
        plt.plot(transaction_counts, latency_values, marker='o', label=algorithm)

    plt.title(f"Latency Comparison with {node_count} Nodes", fontsize=16)
    plt.xlabel("Number of Transactions", fontsize=12)
    plt.ylabel("Average Latency per Transaction (s)", fontsize=12)
    plt.legend()
    plt.grid(linestyle='--', alpha=0.7)
    plt.show()

# 开始运行实验
results = await run_experiments()

# 可视化结果（以 10 个节点为例）
transaction_counts = [1000, 5000, 10000, 50000, 100000]
algorithms = ["PBFT", "Tendermint", "HotStuff", "HotStuff-2"]
plot_throughput(results, transaction_counts, node_count=10, algorithms=algorithms)
plot_latency(results, transaction_counts, node_count=10, algorithms=algorithms)

----------------------------------------------------

#4.1 4.2
import matplotlib.pyplot as plt
import pandas as pd
import random

# Load extended experiment data (assumed previously saved)
df_extended_experiment = pd.read_csv("extended_hotstuff_experiment.csv")

# Plot 1: Consensus Success Rate
plt.figure(figsize=(10, 6))
success_rate_data = df_extended_experiment.groupby(["Quorum Threshold", "Latency Scenario"])["Consensus Success"].apply(
    lambda x: (x == "Yes").mean() * 100).unstack()
success_rate_data.plot(kind="bar", figsize=(12, 7), colormap="viridis", edgecolor="black")
plt.title("Consensus Success Rate by Quorum Threshold and Latency", fontsize=14)
plt.xlabel("Quorum Threshold", fontsize=12)
plt.ylabel("Success Rate (%)", fontsize=12)
plt.xticks(rotation=0)
plt.legend(title="Latency Scenario", fontsize=10)
plt.grid(axis="y", linestyle="--", alpha=0.7)
plt.tight_layout()
plt.savefig("consensus_success_rate.png")
plt.show()

# Plot 2: Communication Complexity
plt.figure(figsize=(12, 7))
communication_cost_data = df_extended_experiment.groupby(["Quorum Threshold", "Latency Scenario"])["Communication Cost"].mean().unstack()
communication_cost_data.plot(kind="bar", figsize=(12, 7), colormap="coolwarm", edgecolor="black")
plt.title("Communication Cost by Quorum Threshold and Latency", fontsize=14)
plt.xlabel("Quorum Threshold", fontsize=12)
plt.ylabel("Average Communication Cost", fontsize=12)
plt.xticks(rotation=0)
plt.legend(title="Latency Scenario", fontsize=10)
plt.grid(axis="y", linestyle="--", alpha=0.7)
plt.tight_layout()
plt.savefig("communication_complexity.png")
plt.show()

# Plot 3: Network Latency Impact on Consensus Success
latency_success_data = df_extended_experiment.groupby(["Latency Scenario"])["Consensus Success"].apply(
    lambda x: (x == "Yes").mean() * 100)
plt.figure(figsize=(10, 6))
latency_success_data.plot(kind="bar", color="skyblue", edgecolor="black")
plt.title("Impact of Network Latency on Consensus Success Rate", fontsize=14)
plt.xlabel("Latency Scenario", fontsize=12)
plt.ylabel("Consensus Success Rate (%)", fontsize=12)
plt.xticks(rotation=0)
plt.grid(axis="y", linestyle="--", alpha=0.7)
plt.tight_layout()
plt.savefig("network_latency_impact.png")
plt.show()

----------------------------------
